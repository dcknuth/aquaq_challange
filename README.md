# aquaq_challange
Coding puzzles from https://challenges.aquaq.co.uk/

## Found these while looking for some additional challenges that look like the Advent of Code challenges. These are a little different and are not from a person using Python by default, but pretty good. I will put a little about each challenge here

* 0 - What's a numpad? - You will generate a message from the input using the old texting/phone input method. I agree with the low difficulty rating listed on this one
* 1 - Rose by any other name - Change a string into an RGB hex color. I didn't know browsers would do that. Neat
* 2 - One is all you need - Remove some bad sections of data. Since the input is short, lots of ways to do this. I probably should have tried to come up with a regex, but just flipped the remaining list a bunch to search in reverse.
* 3 - Short walks - Move square by square until out of instructions. Similar to the easier map walks in Advent of Code
* 4 - This is good co-primen - There are not too many numbers and they are not too large, so a brute force method of doing this one works fine. I stopped there, but could see this with a much larger list with much larger numbers as a later day of Advent of code. Assuming there is a faster prime math way to resolve this
* 5 - Snake eyes - We need to rotate two dice a number of times as given by the input. Again, brute force is fine, and it's not too bad
* 6 - Let me count the ways - Find how many ways you can sum a number. Since we only count the sum of three numbers and the number is not too big we can do this with a two deep nested for, so not too bad.
* 7 - What is best in life? - You are scoring a ping pong tourney using the ELO chess scoring method. The only trouble here was getting the correct order in the (Rb-Ra) part. It was fun to read the Wiki page on chess scoring as I didn't know how they did that. The 400 and 20 constants can also be changed to fit your application and seem to be the middle tier constants used for chess
* 8 - Cron Flakes - Here you run through a daily routine of eating cereal and shopping for groceries. I think this would have a much easier rating except that the instructions have to be read very carefully. I needed to see that milk expires on the fifth day, after you use it and carefully do that part. Also, I needed to note that you are on your first shopping trip of the day when you give your answer, not the second shopping trip of the day (yes, you shop twice a day)
* 9 - Big Data? - Not for Python. Since Python automatically handles very large integers, this is trivial and should be rated 1.6 for Python users
* 10 - Troll Toll - Again, if you use Python and allow yourself the use of NetworkX this is probably a 2.5 level of difficulty. It is a fun one to do and I loved the phrase "how much to get Diddy his fiddy" and after the 2024 accusations, one asks, "What is the fifty for? ;-)"
* 11 - Boxed In - This one was medium hard only as it again requires a careful read and recall of the instructions. Remember you are looking for "total, contiguous tiles needed" not the count of overlapping tiles and not including sections outside the main one with overlaps
* 12 - A Day In The Lift - One needs to read the example very carefully here to get the correct intention. After that, not too bad and in-line with the posted difficulty. Reminds me of the state machine type problems in Advent of Code
* 13 - O RLE? - Count the recurring substring after possibly trimming the front and/or back of the string. Then sum the count for each line. This was not too bad to do brute force by finding all substrings and counting all the consecutive repeats, but it is a bit slow at an average of a couple seconds per line and about 1-2 minutes to get the answer. Each line is independent, so one could run each (or several) in parallel to speed things up if needed
* 14 - That's a bingo - Given a board, play each game until you win and sum the number of draws needed to win all games. Finishes quickly, so nothing tricky needed, but takes a bit of code to get a solution. Easy to understand what the challenge was looking for, which was nice
* 15 - word wore mare maze - You are supposed to change a word to another word, only changing one letter, until you arrive at a target word. After thinking a bit, I figured that I could use NetworkX again (the challenge actually says 'paths+graphs' so maybe it should have been obvious). That's true, but the trouble is in making the network quickly. I made it slowly by removing one word from the list of words given and comparing to all others to see if it was different by exactly one letter. If so, add an edge to the network between those two words. Keep doing this until the word list empties. This works, but takes over 30 minutes to create the network. I will make another version of this one to run faster and update. Until then...
The -2 version first breaks up the words into lists of the same length. This makes the comparison list shorter and we don't have to test for the same length in our function to find if the words are one character different. This version finishes in <10 minutes, so over a 3x speed up
The -3 version uses the same breakup, but uses numpy on the ord values to find all the one-off words faster. This takes about 75 seconds, so we are at at least a 25x speed up, but I was really hoping for 100x
For the -4 version I moved the conversion to integers while reading in the file and used a shorter np.uint8 type, but only gained a couple seconds. I tried to get numpy to work with blas at more than 2 threads on Windows, but totally failed to do anything other than use up a few hours of life. I did update the numpy part to only go over the part of the matrix that had not already been compared, and that got me to about 37 seconds. I'm going to give myself credit for a 50x speedup and call it a day
* 16 - Keming - I assume the name is a joke on a tight kern of 'r' and 'n' turning into an 'm'. You need to count spaces after doing kerning on a series of ascii art letters. Took some thinking and some code, but ran after minimum debugging and only took a couple seconds straight away
* 17 - The Beautiful Shame - You need to find which team had the largest number of days from a game with a score of 0 to a scoring game. I was trying to make this too hard, but still would give it a 4.0 even after thinking of a straight forward way to do it. It also had a read error where I had to force an encoding with the read() function
* 18 - Emit time - Find how many seconds away is the nearest palindromic time and sum those. There is probably a cleaner way to do this or to use a time module, but it ran in <10 seconds, so good enough and not too difficult
* 19 - It's alive - Find how many cells are alive after each game-of-life and sum them up. This was not too difficult, but was slow to run. The first version took 2491 seconds and was basic Python
The -2 version used NumPy and the SciPy convolution2d function. It ran ~8x faster, but still was not using all the CPU codes, similar to the puzzle 15 attempts. Using WinPython did not help as it also seems locked to 2 CPUs via used libraries